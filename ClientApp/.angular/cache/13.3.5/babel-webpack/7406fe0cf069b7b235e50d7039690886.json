{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/services\"; // array in local storage for accounts\n\nconst accountsKey = 'angular-10-signup-verification-boilerplate-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      return handleRoute();\n\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n\n          case url.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n\n          case url.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n\n          case url.endsWith('/accounts/register') && method === 'POST':\n            return register();\n\n          case url.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n\n          case url.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n\n          case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n\n          case url.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n\n          case url.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      } // route functions\n\n\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\n        if (!account) return error('Email or password is incorrect'); // add refresh token to account\n\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n\n      function refreshToken() {\n        const refreshToken = getRefreshToken();\n        if (!refreshToken) return unauthorized();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        if (!account) return unauthorized(); // replace old refresh token with a new one and save\n\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken)); // revoke token and save\n\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n\n      function register() {\n        const account = body;\n\n        if (accounts.find(x => x.email === account.email)) {\n          // display email already registered \"email\" in alert\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                    `, {\n              autoClose: false\n            });\n          }, 1000); // always return ok() response to prevent email enumeration\n\n          return ok();\n        } // assign account id and a few other properties then save\n\n\n        account.id = newAccountId();\n\n        if (account.id === 1) {\n          // first registered account is an admin\n          account.role = Role.Admin;\n        } else {\n          account.role = Role.User;\n        }\n\n        account.dateCreated = new Date().toISOString();\n        account.verificationToken = new Date().getTime().toString();\n        account.isVerified = false;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts)); // display verification email in alert\n\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n          alertService.info(`\n                    <h4>Verification Email</h4>\n                    <p>Thanks for registering!</p>\n                    <p>Please click the below link to verify your email address:</p>\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n        if (!account) return error('Verification failed'); // set is verified flag to true if token is valid\n\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email); // always return ok() response to prevent email enumeration\n\n        if (!account) return ok(); // create reset token that expires after 24 hours\n\n        account.resetToken = new Date().getTime().toString();\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n        localStorage.setItem(accountsKey, JSON.stringify(accounts)); // display password reset email in alert\n\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        return ok();\n      }\n\n      function resetPassword() {\n        const {\n          token,\n          password\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token'); // update password and remove reset token\n\n        account.password = password;\n        account.isVerified = true;\n        delete account.resetToken;\n        delete account.resetTokenExpires;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl()); // user accounts can get own profile and admin accounts can get all profiles\n\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n\n        return ok(basicDetails(account));\n      }\n\n      function createAccount() {\n        if (!isAuthorized(Role.Admin)) return unauthorized();\n        const account = body;\n\n        if (accounts.find(x => x.email === account.email)) {\n          return error(`Email ${account.email} is already registered`);\n        } // assign account id and a few other properties then save\n\n\n        account.id = newAccountId();\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let params = body;\n        let account = accounts.find(x => x.id === idFromUrl()); // user accounts can update own profile and admin accounts can update all profiles\n\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        } // only update password if included\n\n\n        if (!params.password) {\n          delete params.password;\n        } // don't save confirm password\n\n\n        delete params.confirmPassword; // update and save account\n\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(basicDetails(account));\n      }\n\n      function deleteAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl()); // user accounts can delete own account and admin accounts can delete any account\n\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        } // delete account then save\n\n\n        accounts = accounts.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      } // helper functions\n\n\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500)); // delay observable to simulate server api call\n      }\n\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize()); // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648);\n      }\n\n      function unauthorized() {\n        return throwError({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified\n        };\n      }\n\n      function isAuthenticated() {\n        return !!currentAccount();\n      }\n\n      function isAuthorized(role) {\n        const account = currentAccount();\n        if (!account) return false;\n        return account.role === role;\n      }\n\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n\n      function currentAccount() {\n        // check if jwt token is in auth header\n        const authHeader = headers.get('Authorization');\n        if (!authHeader.startsWith('Bearer fake-jwt-token')) return; // check if token is expired\n\n        const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n        const tokenExpired = Date.now() > jwtToken.exp * 1000;\n        if (tokenExpired) return;\n        const account = accounts.find(x => x.id === jwtToken.id);\n        return account;\n      }\n\n      function generateJwtToken(account) {\n        // create token that expires in 15 minutes\n        const tokenPayload = {\n          exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n\n      function generateRefreshToken() {\n        const token = new Date().getTime().toString(); // add token cookie that expires in 7 days\n\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n        return token;\n      }\n\n      function getRefreshToken() {\n        // get refresh token from cookie\n        return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n      }\n    }\n\n  }\n\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n  };\n\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport let fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module"}